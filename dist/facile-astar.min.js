!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["facile-astar"]=t["facile-astar"]||{})}(this,(function(t){"use strict";var e;const s=new ArrayBuffer(16),i=new Float64Array(s),n=new Int32Array(s);class r{constructor(t,e){this.x=t,this.y=e,i[0]=t,i[1]=e,this._hashed=n[0]^n[1]^n[2]^n[3]}get hashCode(){return this._hashed}dot(t){return this.x*t.x+this.y*t.y}get length(){return Math.sqrt(this.dot(this))}sin(){return this.y/this.length}cos(){return this.x/this.length}sub(t){return new r(this.x-t.x,this.y-t.y)}add(t){return new r(this.x+t.x,this.y+t.y)}scale(t,e){return new r(this.x*t,this.y*e)}angle(t){return Math.atan2(this.y-t.y,this.x-t.x)}angleD(t){return h.toDegree(this.angle(t))}distance1(t){return class{static hypot(t,e){if(t=Math.abs(t),(e=Math.abs(e))>t&&(e^=t,e^=t^=e),0===t)return e;const s=e/t;return t*Math.sqrt(1+s*s)}}.hypot(t.x-this.x,t.y-this.y)}distance2(t){const e=t.x-this.x,s=t.y-this.y;return e*e+s*s}rotate(t,e){const s=Math.cos(e),i=Math.sin(e),n=this.x-t.x,h=this.y-t.y,a=n*s+h*-i,o=n*i+h*s;return t.add(new r(a,o))}rotateD(t,e){return this.rotate(t,h.toRadian(e))}equal(t){return t.x===this.x&&t.y===this.y}*[Symbol.iterator](){yield this.x,yield this.y}bbox(){return new a(this.x,this.x,this.y,this.y)}toString(){return`Vector2 [X="${this.x}", Y="${this.y}"]`}}e=r,r.ORIGIN=new e(0,0);class h{static toDegree(t){return 180*t/Math.PI}static toRadian(t){return t/180*Math.PI}}class a{constructor(t,e,s,i){this.minX=t,this.maxX=e,this.minY=s,this.maxY=i}isContain(t){return this.isContainX(t.x)&&this.isContainY(t.y)}isContainX(t){return t>=this.minX&&t<=this.maxX}isContainY(t){return t>=this.minY&&t<=this.maxY}}class o{constructor(){this.init()}extend1(t){return this.minX=Math.min(this.minX,t.minX),this.maxY=Math.max(this.maxX,t.maxX),this.minY=Math.min(this.minY,t.minY),this.maxY=Math.max(this.maxX,t.maxY),this}extend2(t){return this.minX=Math.min(this.minX,t.x),this.maxX=Math.max(this.maxX,t.x),this.minY=Math.min(this.minY,t.y),this.maxY=Math.max(this.maxY,t.y),this}extend3(t){for(let e=0;e<t.length;e++)this.extend2(t[e]);return this}extend4(t,e,s,i){return this.minX=Math.min(this.minX,t),this.maxX=Math.max(this.maxX,e),this.minY=Math.min(this.minY,s),this.maxY=Math.max(this.maxY,i),this}extend5(t){if(t<0){const e=2*t;if(e<this.minX-this.maxX||e<this.minY-this.maxY)return this}return this.minX-=t,this.maxX+=t,this.minY-=t,this.maxY+=t,this}init(){this.minX=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY}valid(){return[this.minX,this.maxX,this.minY,this.maxY].every(Number.isFinite)}build(){return new a(this.minX,this.maxX,this.minY,this.maxY)}}class u{constructor(t){this.value=t,this.previous=null,this.next=null}}class l{constructor(){this.map=new Map,this.head=null,this.tail=null}get size(){return this.map.size}insertBefore(t,e){this.map.has(e)&&this.delete(e);const s=new u(e);return this.map.set(e,s),null===t?(this.head===t&&(this.head=s),this.tail===t&&(this.tail=s)):(this.head===t&&(this.head=s),(s.previous=t.previous)&&(s.previous.next=s),s.next=t,t.previous=s),s}insertAfter(t,e){this.map.has(e)&&this.delete(e);const s=new u(e);return this.map.set(e,s),null===t?(this.head===t&&(this.head=s),this.tail===t&&(this.tail=s)):(this.tail===t&&(this.tail=s),(s.next=t.next)&&(s.next.previous=s),s.previous=t,t.next=s),s}shift(t){return this.insertBefore(this.head,t)}push(t){return this.insertAfter(this.tail,t)}delete(t){if(!(t instanceof u)){const e=this.map.get(t);if(!e)return;t=e}if(this.map.delete(t.value),null===t.next&&null===t.previous)return this.head=null,void(this.tail=null);t.next&&((t.next.previous=t.previous)||(this.head=t.next)),t.previous&&((t.previous.next=t.next)||(this.tail=t.previous))}toArray(){const t=[];let e=this.head;for(;e;)t.push(e),e=e.next;return t}fromArray(t){for(let e=0;e<t.length;e++)this.push(t[e]);return this}reverse(){let t=this.head,e=null,s=null;for(;t;)s=t.next,e=t.previous,t.next=e,t.previous=s,e=t,t=s;return this.tail=this.head,this.head=e,this}}class c extends l{constructor(t){super(),this.comparator=t}insert(t){const{_insert:e}=this;e&&e(t);let s=this.head;if(!s)return this.insertBefore(s,t);do{if(this.comparator(t,s.value))return this.insertBefore(s,t);s=s.next}while(s);return this.insertAfter(this.tail,t)}poll(){let t=this.head;if(t){const{_poll:e}=this,s=[];let i=t;do{s.push(i),this.delete(i),e&&e(i.value)}while(i.next&&(i=i.next)&&this.comparator(i.value,t.value));return s}return null}}class m{constructor(t){this.compareFunc=t,this.equal=(...t)=>0===this.compareFunc(...t),this.lessThan=(...t)=>this.compareFunc(...t)<0,this.greaterThan=(...t)=>this.compareFunc(...t)>0,this.lessOrEqualThan=(...t)=>this.equal(...t)||this.lessThan(...t)}}function p(t){return null==t}const x=Object.freeze(new Array),d=new m(((t,e)=>t.F-e.F)).lessOrEqualThan;class y extends r{constructor(t,e){super(t,e),this.parent=null,this.G=0,this.H=0,this.key=`${t}|${e}`}get F(){return this.G+this.H}updateG(t){this.G=t||y.calcG(this,this.parent)}updateH(t){this.H=y.calcH(this,t)}static calcG(t,e){return(t.x===e.x||t.y===e.y?10:14)+e.G}static calcH(t,e){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)}}var f;t.RouteType=void 0,(f=t.RouteType||(t.RouteType={})).all="all",f.diagonal="diagonal",f.orthometric="orthometric";const Y={step:10,routeType:t.RouteType.all};class X extends c{constructor(){super(d),this.pointKeyMap=new Map,this._insert=t=>{this.pointKeyMap.set(t.key,t)},this._poll=t=>{this.pointKeyMap.delete(t.key)}}has(t){return this.pointKeyMap.has(t)}get(t){return this.pointKeyMap.get(t)}}t.AStar=class{constructor(t){this.openListQueue=new X,this.closeList=new Map,this.canSearch=!0,t.step??(t.step=Y.step),t.routeType??(t.routeType=Y.routeType),this.start=t.start,this.end=t.end,this.step=t.step,this.routeType=t.routeType,this.blockArea=t.blockArea,this.boundaryArea=t.boundaryArea;(()=>{if(!this.blockArea)return;const t=[this.start,this.end];return this.blockArea.some((e=>t.some((t=>e.isContain(t)))))})()&&(this.canSearch=!1)}_runOne(t){const{end:e,step:s}=this;let i;if(this.traverseAroundPoints(t,((n,r)=>{const h=n.distance2(e);if(h<s**2)return n.parent=t,0===h?i=n:(e.parent=n,i=e),!0;r?this.foundPointNode(t,n):this.notFoundPointNode(t,n)})),i)return i;this.openListQueue.delete(t),this.closeList.set(t.key,t)}traverseAroundPoints(e,s){const i=(new o).extend2(e).extend5(this.step).build();let n;const r=()=>[[i.minX,i.minY],[i.minX,i.maxY],[i.maxX,i.maxY],[i.maxX,i.minY]],h=()=>[[i.minX,e.y],[e.x,i.minY],[i.maxX,e.y],[e.x,i.maxY]];switch(this.routeType){case t.RouteType.orthometric:n=h();break;case t.RouteType.diagonal:n=r();break;case t.RouteType.all:default:n=[...h(),...r()]}n.some((t=>{const e=this.openListQueue.get(t.join("|")),i=e||new y(...t);if(this.canReach(i))return s(i,!!e)}))}search(){if(!this.canSearch)return x;const{openListQueue:t}=this;this.start.updateH(this.end),t.insert(this.start);const e=[];do{const s=t.poll();if(s)for(const t of s){const s=this._runOne(t.value);if(s)return e.push(this.getResult(s)),e}}while(t.size)}notFoundPointNode(t,e){e.parent=t,e.updateG(),e.updateH(this.end),this.openListQueue.insert(e)}foundPointNode(t,e){const s=e.G,i=y.calcG(e,t);i<s&&(e.parent=t,e.updateG(i),this.openListQueue.insert(e))}getResult(t){const e=[t];for(;t.parent;)e.push(t=t.parent);return e.reverse()}canReach(t){return!this.closeList.has(t.key)&&((!this.blockArea||!this.blockArea.some((e=>e.isContain(t))))&&!(this.boundaryArea&&!this.boundaryArea.isContain(t)))}},t.AbstractPriorityQueue=c,t.Angle=h,t.BBox2=a,t.BBox2Factory=o,t.Comparator=m,t.DoublyLinkedList=l,t.DoublyLinkedListNode=u,t.EMPTY_ARRAY=x,t.RoutePointNode=y,t.Vector2=r,t.extend=function(t,e){for(const s in t)p(t[s])&&(t[s]=e[s]);return t},t.isUndef=p,Object.defineProperty(t,"__esModule",{value:!0})}));
