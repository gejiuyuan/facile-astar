!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["facile-astar"]=t["facile-astar"]||{})}(this,(function(t){"use strict";var e;const i=new ArrayBuffer(16),s=new Float64Array(i),n=new Int32Array(i);class r{constructor(t,e){this.x=t,this.y=e,s[0]=t,s[1]=e,this._hashed=n[0]^n[1]*n[2]^n[3]}get hashCode(){return this._hashed}dot(t){return this.x*t.x+this.y*t.y}get length(){return Math.sqrt(this.dot(this))}sin(){return this.y/this.length}cos(){return this.x/this.length}sub(t){return new r(this.x-t.x,this.y-t.y)}add(t){return new r(this.x+t.x,this.y+t.y)}scale(t,e){return new r(this.x*t,this.y*e)}angle(t){return Math.atan2(this.y-t.y,this.x-t.x)}angleD(t){return h.toDegree(this.angle(t))}distance1(t){return class{static hypot(t,e){if(t=Math.abs(t),(e=Math.abs(e))>t&&(e^=t,e^=t^=e),0===t)return e;const i=e/t;return t*Math.sqrt(1+i*i)}}.hypot(t.x-this.x,t.y-this.y)}distance2(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}rotate(t,e){const i=Math.cos(e),s=Math.sin(e),n=this.x-t.x,h=this.y-t.y,a=n*i+h*-s,o=n*s+h*i;return t.add(new r(a,o))}rotateD(t,e){return this.rotate(t,h.toRadian(e))}equal(t){return t.x===this.x&&t.y===this.y}*[Symbol.iterator](){yield this.x,yield this.y}bbox(){return new a(this.x,this.x,this.y,this.y)}toString(){return`Vector2 [X="${this.x}", Y="${this.y}"]`}}e=r,r.ORIGIN=new e(0,0);class h{static toDegree(t){return 180*t/Math.PI}static toRadian(t){return t/180*Math.PI}}class a{constructor(t,e,i,s){this.minX=t,this.maxX=e,this.minY=i,this.maxY=s}isContain(t){return this.isContainX(t.x)&&this.isContainY(t.y)}isContainX(t){return t>=this.minX&&t<=this.maxX}isContainY(t){return t>=this.minY&&t<=this.maxY}}class o{constructor(){this.init()}extend1(t){return this.minX=Math.min(this.minX,t.minX),this.maxY=Math.max(this.maxX,t.maxX),this.minY=Math.min(this.minY,t.minY),this.maxY=Math.max(this.maxX,t.maxY),this}extend2(t){return this.minX=Math.min(this.minX,t.x),this.maxX=Math.max(this.maxX,t.x),this.minY=Math.min(this.minY,t.y),this.maxY=Math.max(this.maxY,t.y),this}extend3(t){for(let e=0;e<t.length;e++)this.extend2(t[e]);return this}extend4(t,e,i,s){return this.minX=Math.min(this.minX,t),this.maxX=Math.max(this.maxX,e),this.minY=Math.min(this.minY,i),this.maxY=Math.max(this.maxY,s),this}extend5(t){if(t<0){const e=2*t;if(e<this.minX-this.maxX||e<this.minY-this.maxY)return this}return this.minX-=t,this.maxX+=t,this.minY-=t,this.maxY+=t,this}init(){this.minX=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY}valid(){return[this.minX,this.maxX,this.minY,this.maxY].every(Number.isFinite)}build(){return new a(this.minX,this.maxX,this.minY,this.maxY)}}function u(t){return null==t}const c=Object.freeze(new Array);class m extends r{constructor(t,e){super(t,e),this.parent=null,this.G=0,this.H=0,this.key=`${t}|${e}`}get F(){return this.G+this.H}updateG(t){this.G=t||m.calcG(this,this.parent)}updateH(t){this.H=m.calcH(this,t)}static calcG(t,e){return(t.x===e.x||t.y===e.y?10:14)+e.G}static calcH(t,e){return 10*(Math.abs(t.x-e.y)+Math.abs(t.y-e.y))}getAround(e,i){const s=(new o).extend2(this).extend5(e).build(),n=()=>[new m(s.minX,s.minY),new m(s.minX,s.maxY),new m(s.maxX,s.maxY),new m(s.maxX,s.minY)],r=()=>[new m(s.minX,this.y),new m(this.x,s.minY),new m(s.maxX,this.y),new m(this.x,s.maxY)];switch(i){case t.RouteType.orthometric:return r();case t.RouteType.diagonal:return n();case t.RouteType.all:default:return[...r(),...n()]}}}var x;t.RouteType=void 0,(x=t.RouteType||(t.RouteType={})).all="all",x.diagonal="diagonal",x.orthometric="orthometric";const l={step:10,routeType:t.RouteType.all};t.AStar=class{constructor(t){this.openList=new Map,this.closeList=new Map,this.canSearch=!0,t.step??(t.step=l.step),t.routeType??(t.routeType=l.routeType),this.start=t.start,this.end=t.end,this.step=t.step,this.routeType=t.routeType,this.blockArea=t.blockArea,this.boundaryArea=t.boundaryArea;(()=>{if(!this.blockArea)return;const t=[this.start,this.end];return this.blockArea.some((e=>t.some((t=>e.isContain(t)))))})()&&(this.canSearch=!1)}_runOne(t){const{end:e,step:i,routeType:s,openList:n}=this,r=t.getAround(i,s).filter((t=>this.canReach(t)));for(let s=0;s<r.length;s++){const h=r[s],a=h.distance1(e);if(a<i)return h.parent=t,0===a?h:(e.parent=h,e);if(n.has(h.key)){const e=h.G,i=m.calcG(h,t);i<e&&(h.parent=t,h.updateG(i))}else n.set(h.key,h),h.parent=t,h.updateG(),h.updateH(e)}n.delete(t.key),this.closeList.set(t.key,t)}search(){if(!this.canSearch)return c;const{openList:t}=this;t.set(this.start.key,this.start);do{const t=this.getMinFNodeInOpenList(),e=this._runOne(t);if(e)return this.getResult(e)}while(t.size)}getResult(t){const e=[t];for(;t.parent;)e.push(t=t.parent);return e.reverse()}getMinFNodeInOpenList(){let t;for(const[,e]of this.openList)(void 0===t||e.F<t.F)&&(t=e);return t}canReach(t){return!this.closeList.has(t.key)&&((!this.blockArea||!this.blockArea.some((e=>e.isContain(t))))&&!(this.boundaryArea&&!this.boundaryArea.isContain(t)))}},t.Angle=h,t.BBox2=a,t.BBox2Factory=o,t.EMPTY_ARRAY=c,t.RoutePointNode=m,t.Vector2=r,t.extend=function(t,e){for(const i in t)u(t[i])&&(t[i]=e[i]);return t},t.isUndef=u,Object.defineProperty(t,"__esModule",{value:!0})}));
