!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["facile-astar"]=t["facile-astar"]||{})}(this,(function(t){"use strict";var e;const s=new ArrayBuffer(16),i=new Float64Array(s),n=new Int32Array(s);class r{constructor(t,e){this.x=t,this.y=e,i[0]=t,i[1]=e,this._hashed=n[0]^n[1]^n[2]^n[3]}get hashCode(){return this._hashed}dot(t){return this.x*t.x+this.y*t.y}get length(){return Math.sqrt(this.dot(this))}sin(){return this.y/this.length}cos(){return this.x/this.length}sub(t){return new r(this.x-t.x,this.y-t.y)}add(t){return new r(this.x+t.x,this.y+t.y)}scale(t,e){return new r(this.x*t,this.y*e)}angle(t){return Math.atan2(this.y-t.y,this.x-t.x)}angleD(t){return h.toDegree(this.angle(t))}distance1(t){return class{static hypot(t,e){if(t=Math.abs(t),(e=Math.abs(e))>t&&(e^=t,e^=t^=e),0===t)return e;const s=e/t;return t*Math.sqrt(1+s*s)}}.hypot(t.x-this.x,t.y-this.y)}distance2(t){const e=t.x-this.x,s=t.y-this.y;return e*e+s*s}rotate(t,e){const s=Math.cos(e),i=Math.sin(e),n=this.x-t.x,h=this.y-t.y,a=n*s+h*-i,o=n*i+h*s;return t.add(new r(a,o))}rotateD(t,e){return this.rotate(t,h.toRadian(e))}equal(t){return t.x===this.x&&t.y===this.y}*[Symbol.iterator](){yield this.x,yield this.y}bbox(){return new a(this.x,this.x,this.y,this.y)}toString(){return`Vector2 [X="${this.x}", Y="${this.y}"]`}}e=r,r.ORIGIN=new e(0,0);class h{static toDegree(t){return 180*t/Math.PI}static toRadian(t){return t/180*Math.PI}}class a{constructor(t,e,s,i){this.minX=t,this.maxX=e,this.minY=s,this.maxY=i}isContain(t){return this.isContainX(t.x)&&this.isContainY(t.y)}isContainX(t){return t>=this.minX&&t<=this.maxX}isContainY(t){return t>=this.minY&&t<=this.maxY}}class o{constructor(){this.init()}extend1(t){return this.minX=Math.min(this.minX,t.minX),this.maxY=Math.max(this.maxX,t.maxX),this.minY=Math.min(this.minY,t.minY),this.maxY=Math.max(this.maxX,t.maxY),this}extend2(t){return this.minX=Math.min(this.minX,t.x),this.maxX=Math.max(this.maxX,t.x),this.minY=Math.min(this.minY,t.y),this.maxY=Math.max(this.maxY,t.y),this}extend3(t){for(let e=0;e<t.length;e++)this.extend2(t[e]);return this}extend4(t,e,s,i){return this.minX=Math.min(this.minX,t),this.maxX=Math.max(this.maxX,e),this.minY=Math.min(this.minY,s),this.maxY=Math.max(this.maxY,i),this}extend5(t){if(t<0){const e=2*t;if(e<this.minX-this.maxX||e<this.minY-this.maxY)return this}return this.minX-=t,this.maxX+=t,this.minY-=t,this.maxY+=t,this}init(){this.minX=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY}valid(){return[this.minX,this.maxX,this.minY,this.maxY].every(Number.isFinite)}build(){return new a(this.minX,this.maxX,this.minY,this.maxY)}}class u{constructor(t){this.value=t,this.previous=null,this.next=null}}class l{constructor(){this.head=null,this.tail=null}insertBefore(t,e){const s=new u(e);return null===t?(this.head===t&&(this.head=s),this.tail===t&&(this.tail=s)):(this.head===t&&(this.head=s),(s.previous=t.previous)&&(s.previous.next=s),s.next=t,t.previous=s),s}insertAfter(t,e){const s=new u(e);return null===t?(this.head===t&&(this.head=s),this.tail===t&&(this.tail=s)):(this.tail===t&&(this.tail=s),(s.next=t.next)&&(s.next.previous=s),s.previous=t,t.next=s),s}shift(t){return this.insertBefore(this.head,t)}push(t){return this.insertAfter(this.tail,t)}delete(t){if(null===t.next&&null===t.previous)return this.head=null,void(this.tail=null);t.next&&((t.next.previous=t.previous)||(this.head=t.next)),t.previous&&((t.previous.next=t.next)||(this.tail=t.previous))}toArray(){const t=[];let e=this.head;for(;e;)t.push(e),e=e.next;return t}fromArray(t){for(let e=0;e<t.length;e++)this.push(t[e]);return this}reverse(){let t=this.head,e=null,s=null;for(;t;)s=t.next,e=t.previous,t.next=e,t.previous=s,e=t,t=s;return this.tail=this.head,this.head=e,this}}class c extends l{constructor(t){super(),this.comparator=t}insert(t){let e=this.head;if(!e)return this.insertBefore(e,t);do{if(this.comparator(t,e.value))return this.insertBefore(e,t);e=e.next}while(e);return this.insertAfter(this.tail,t)}poll(){let t=this.head;if(t){const e=[];let s=t;do{e.push(s.value),this.delete(s)}while(s.next&&(s=s.next)&&this.comparator(s.value,t.value));return e}return null}}class d{constructor(t){this.compareFunc=t,this.equal=(...t)=>0===this.compareFunc(...t),this.lessThan=(...t)=>this.compareFunc(...t)<0,this.greaterThan=(...t)=>this.compareFunc(...t)>0,this.lessOrEqualThan=(...t)=>this.equal(...t)||this.lessThan(...t)}}function m(t){return null==t}const x=Object.freeze(new Array);class p{constructor(t){this.node=t,this.modCount=t.modCount}noChanged(){return this.modCount===this.node.modCount}}p.comparator=new d(((t,e)=>t.node.F-e.node.F)).lessOrEqualThan;class y extends r{constructor(t,e){super(t,e),this.parent=null,this.G=0,this.H=0,this.modCount=0,this.key=`${t}|${e}`}get F(){return this.G+this.H}updateG(t){this.G=t||y.calcG(this,this.parent)}updateH(t){this.H=y.calcH(this,t)}static calcG(t,e){return(t.x===e.x||t.y===e.y?10:14)+e.G}static calcH(t,e){return 10*(Math.abs(t.x-e.x)+Math.abs(t.y-e.y))}getAround(e,s){const i=(new o).extend2(this).extend5(e).build(),n=()=>[new y(i.minX,i.minY),new y(i.minX,i.maxY),new y(i.maxX,i.maxY),new y(i.maxX,i.minY)],r=()=>[new y(i.minX,this.y),new y(this.x,i.minY),new y(i.maxX,this.y),new y(this.x,i.maxY)];switch(s){case t.RouteType.orthometric:return r();case t.RouteType.diagonal:return n();case t.RouteType.all:default:return[...r(),...n()]}}}var f;t.RouteType=void 0,(f=t.RouteType||(t.RouteType={})).all="all",f.diagonal="diagonal",f.orthometric="orthometric";const Y={step:10,routeType:t.RouteType.all};t.AStar=class{constructor(t){this.queue=new c(p.comparator),this.openList=new Map,this.closeList=new Map,this.canSearch=!0,t.step??(t.step=Y.step),t.routeType??(t.routeType=Y.routeType),this.start=t.start,this.end=t.end,this.step=t.step,this.routeType=t.routeType,this.blockArea=t.blockArea,this.boundaryArea=t.boundaryArea;(()=>{if(!this.blockArea)return;const t=[this.start,this.end];return this.blockArea.some((e=>t.some((t=>e.isContain(t)))))})()&&(this.canSearch=!1)}_runOne(t){const{end:e,step:s,routeType:i,openList:n}=this,r=t.getAround(s,i).filter((t=>this.canReach(t)));for(let i=0;i<r.length;i++){const h=r[i],a=h.distance2(e);if(a<s**2)return h.parent=t,0===a?h:(e.parent=h,e);n.has(h.key)?this.foundPointNode(t,h):this.notFoundPointNode(t,h)}n.delete(t.key),this.closeList.set(t.key,t)}search(){if(!this.canSearch)return x;const{openList:t,queue:e}=this;t.set(this.start.key,this.start),this.start.updateH(this.end),e.insert(new p(this.start));do{const t=e.poll();if(t)for(const e of t){const t=this._runOne(e.node);if(t)return this.getResult(t)}}while(t.size)}notFoundPointNode(t,e){e.parent=t,e.updateG(),e.updateH(this.end),e.modCount++,this.openList.set(e.key,e),this.queue.insert(new p(e))}foundPointNode(t,e){const s=e.G,i=y.calcG(e,t);i<s&&(e.parent=t,e.updateG(i),e.modCount++,this.queue.insert(new p(e)))}getResult(t){const e=[t];for(;t.parent;)e.push(t=t.parent);return e.reverse()}canReach(t){return!this.closeList.has(t.key)&&((!this.blockArea||!this.blockArea.some((e=>e.isContain(t))))&&!(this.boundaryArea&&!this.boundaryArea.isContain(t)))}},t.Angle=h,t.BBox2=a,t.BBox2Factory=o,t.Comparator=d,t.DoublyLinkedList=l,t.DoublyLinkedListNode=u,t.EMPTY_ARRAY=x,t.PriorityQueue=c,t.RoutePointNode=y,t.Vector2=r,t.extend=function(t,e){for(const s in t)m(t[s])&&(t[s]=e[s]);return t},t.isUndef=m,Object.defineProperty(t,"__esModule",{value:!0})}));
