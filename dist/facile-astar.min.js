!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports):"function"==typeof define&&define.amd?define(["exports"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self)["facile-astar"]=t["facile-astar"]||{})}(this,(function(t){"use strict";var i;const e=new ArrayBuffer(16),s=new Float64Array(e),n=new Int32Array(e);class r{constructor(t,i){this.x=t,this.y=i,s[0]=t,s[1]=i,this._hashed=n[0]^n[1]^n[2]^n[3]}get hashCode(){return this._hashed}dot(t){return this.x*t.x+this.y*t.y}get length(){return Math.sqrt(this.dot(this))}sin(){return this.y/this.length}cos(){return this.x/this.length}sub(t){return new r(this.x-t.x,this.y-t.y)}add(t){return new r(this.x+t.x,this.y+t.y)}scale(t,i){return new r(this.x*t,this.y*i)}angle(t){return Math.atan2(this.y-t.y,this.x-t.x)}angleD(t){return a.toDegree(this.angle(t))}distance1(t){return class{static hypot(t,i){if(t=Math.abs(t),(i=Math.abs(i))>t&&(i^=t,i^=t^=i),0===t)return i;const e=i/t;return t*Math.sqrt(1+e*e)}}.hypot(t.x-this.x,t.y-this.y)}distance2(t){const i=t.x-this.x,e=t.y-this.y;return i*i+e*e}rotate(t,i){const e=Math.cos(i),s=Math.sin(i),n=this.x-t.x,a=this.y-t.y,h=n*e+a*-s,o=n*s+a*e;return t.add(new r(h,o))}rotateD(t,i){return this.rotate(t,a.toRadian(i))}equal(t){return t.x===this.x&&t.y===this.y}*[Symbol.iterator](){yield this.x,yield this.y}bbox(){return new h(this.x,this.x,this.y,this.y)}toString(){return`Vector2 [X="${this.x}", Y="${this.y}"]`}}i=r,r.ORIGIN=new i(0,0);class a{static toDegree(t){return 180*t/Math.PI}static toRadian(t){return t/180*Math.PI}}class h{constructor(t,i,e,s){this.minX=t,this.maxX=i,this.minY=e,this.maxY=s}isContain(t){return this.isContainX(t.x)&&this.isContainY(t.y)}isContainX(t){return t>=this.minX&&t<=this.maxX}isContainY(t){return t>=this.minY&&t<=this.maxY}}class o{constructor(){this.init()}extend1(t){return this.minX=Math.min(this.minX,t.minX),this.maxY=Math.max(this.maxX,t.maxX),this.minY=Math.min(this.minY,t.minY),this.maxY=Math.max(this.maxX,t.maxY),this}extend2(t){return this.minX=Math.min(this.minX,t.x),this.maxX=Math.max(this.maxX,t.x),this.minY=Math.min(this.minY,t.y),this.maxY=Math.max(this.maxY,t.y),this}extend3(t){for(let i=0;i<t.length;i++)this.extend2(t[i]);return this}extend4(t,i,e,s){return this.minX=Math.min(this.minX,t),this.maxX=Math.max(this.maxX,i),this.minY=Math.min(this.minY,e),this.maxY=Math.max(this.maxY,s),this}extend5(t){if(t<0){const i=2*t;if(i<this.minX-this.maxX||i<this.minY-this.maxY)return this}return this.minX-=t,this.maxX+=t,this.minY-=t,this.maxY+=t,this}init(){this.minX=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY}valid(){return[this.minX,this.maxX,this.minY,this.maxY].every(Number.isFinite)}build(){return new h(this.minX,this.maxX,this.minY,this.maxY)}}class u{constructor(t){this.comparator=t,this.binaryHeap=new Array,this.count=0}size(){return this.count}add(t){this.count>0?this.siftUp(this.count,t):this.binaryHeap[0]=t,this.count++}remove(t){let i=this.binaryHeap.indexOf(t);i>-1&&(this.binaryHeap.splice(i,1),this.count--),this.count<0&&(this.count=0)}poll(){for(;;){if(this.count>0){this.count--;const t=this.binaryHeap[0];return this.count>0&&this.siftDown(0,this.binaryHeap[this.count]),t}return null}}siftUp(t,i){for(;t>0;){const e=t-1>>>1,s=this.binaryHeap[e];if(this.comparator(i,s)>0)break;this.binaryHeap[t]=s,t=e}this.binaryHeap[t]=i}siftDown(t,i){const e=this.count>>>1;for(;t<e;){let e=1+(t<<1),s=this.binaryHeap[e];const n=e+1;if(n<this.count){const t=this.binaryHeap[n];this.comparator(s,t)>0&&(e=n,s=t)}if(this.comparator(i,s)<=0)break;this.binaryHeap[t]=s,t=e}this.binaryHeap[t]=i}}function c(t){return null==t}const m=Object.freeze(new Array);class d{constructor(t){this.node=t,this.modCount=t.modCount}noChanged(){return this.modCount===this.node.modCount}static comparator(t,i){return t.node.F-i.node.F}}class x extends r{constructor(t,i){super(t,i),this.parent=null,this.G=0,this.H=0,this.modCount=0,this.key=`${t}|${i}`}get F(){return this.G+this.H}updateG(t){this.G=t||x.calcG(this,this.parent)}updateH(t){this.H=x.calcH(this,t)}static calcG(t,i){return(t.x===i.x||t.y===i.y?10:14)+i.G}static calcH(t,i){return 10*(Math.abs(t.x-i.x)+Math.abs(t.y-i.y))}getAround(i,e){const s=(new o).extend2(this).extend5(i).build(),n=()=>[new x(s.minX,s.minY),new x(s.minX,s.maxY),new x(s.maxX,s.maxY),new x(s.maxX,s.minY)],r=()=>[new x(s.minX,this.y),new x(this.x,s.minY),new x(s.maxX,this.y),new x(this.x,s.maxY)];switch(e){case t.RouteType.orthometric:return r();case t.RouteType.diagonal:return n();case t.RouteType.all:default:return[...r(),...n()]}}}var y;t.RouteType=void 0,(y=t.RouteType||(t.RouteType={})).all="all",y.diagonal="diagonal",y.orthometric="orthometric";const l={step:10,routeType:t.RouteType.all};t.AStar=class{constructor(t){this.queue=new u(d.comparator),this.openList=new Map,this.closeList=new Map,this.canSearch=!0,t.step??(t.step=l.step),t.routeType??(t.routeType=l.routeType),this.start=t.start,this.end=t.end,this.step=t.step,this.routeType=t.routeType,this.blockArea=t.blockArea,this.boundaryArea=t.boundaryArea;(()=>{if(!this.blockArea)return;const t=[this.start,this.end];return this.blockArea.some((i=>t.some((t=>i.isContain(t)))))})()&&(this.canSearch=!1)}_runOne(t){const{end:i,step:e,routeType:s,openList:n}=this,r=t.getAround(e,s).filter((t=>this.canReach(t)));for(let s=0;s<r.length;s++){const a=r[s],h=a.distance2(i);if(h<e**2)return a.parent=t,0===h?a:(i.parent=a,i);n.has(a.key)?this.foundPointNode(t,a):this.notFoundPointNode(t,a)}n.delete(t.key),this.closeList.set(t.key,t)}search(){if(!this.canSearch)return m;const{openList:t,queue:i}=this;t.set(this.start.key,this.start),i.add(new d(this.start));do{const t=this.getMinFNodeInOpenList();if(t){const i=this._runOne(t);if(i)return this.getResult(i)}}while(t.size)}notFoundPointNode(t,i){i.parent=t,i.updateG(),i.updateH(this.end),i.modCount++,this.openList.set(i.key,i),this.queue.add(new d(i))}foundPointNode(t,i){const e=i.G,s=x.calcG(i,t);s<e&&(i.parent=t,i.updateG(s),i.modCount++,this.queue.add(new d(i)))}getResult(t){const i=[t];for(;t.parent;)i.push(t=t.parent);return i.reverse()}getMinFNodeInOpenList(){for(;;){const t=this.queue.poll();if(null===t)return null;if(t.noChanged())return t.node}}canReach(t){return!this.closeList.has(t.key)&&((!this.blockArea||!this.blockArea.some((i=>i.isContain(t))))&&!(this.boundaryArea&&!this.boundaryArea.isContain(t)))}},t.Angle=a,t.BBox2=h,t.BBox2Factory=o,t.EMPTY_ARRAY=m,t.PriorityQueue=u,t.RoutePointNode=x,t.Vector2=r,t.extend=function(t,i){for(const e in t)c(t[e])&&(t[e]=i[e]);return t},t.isUndef=c,Object.defineProperty(t,"__esModule",{value:!0})}));
